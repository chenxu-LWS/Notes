# Paxos

> Raft作为常用的共识算法，其写作缘由实际上是对Paxos进行简化和优化。这极大的激发了我的兴趣，于是对Paxos的原文进行了拜读。
>
> Paxos的原文 - 《The part-time parliament》。
>
> 这篇论文的写作手法十分抽象，大概讲了在Paxos岛屿上进行会议决议的方式，用阅读计算机论文的思维方式实在是难以理解...
>
> 后人根据这篇翻译为简易版本，使得Paxos更容易被读懂。其中Leslie Lamport的《Paxos Made Simple》是广为众人认可的一篇。

## 介绍

Paxos作为一个实现分布式系统容错机制的算法，常被认为难以理解，这可能是因为其原论文是希腊文。实际上Paxos是所有分布式算法中最简单且最明晰的，其核心是一种共识算法。下一节我们会重点阐述为什么我们必需这个共识算法，以及它如何满足了我们需要的特性；而最后一节我们将解释整个Paxos算法，并将Paxos算法直接应用于一个简单的分布式系统的复制状态机实现。

## 共识算法

### 什么是共识

假设一组进程，他们可以产生结果值（values）。一个共识算法保证会从这些值中选出一个，如果没有值生成，则不会进行选择。且一个值被选择后，所有的进程都需要可以感知到这个值。

对于共识有几个安全性（产生正确的输出）的需求：

* 只能在产生的值中进行选择
* 只能选择一个值
* 一个进程不会感知没有被选中的值

共识算法的目的就是为了选举出一个值，并使所有进程感知到这个值被选中了。

针对这个问题，在Paxos中我们**抽象出了三种Agent**（这里翻译成代理可能有点奇怪）：**Proposers，Acceptors，Learners**。（Proposer提出提案，Acceptor负责接收提案和投票、Learners感知已经被票决出来的提案）每个进程可以同时扮演不同的角色，但实际上这个映射关系我们并不关心，因为Paxos以Agent为单位进行实现。

假设Agents之间可以互相发送消息以进行通信。我们采用常用的非拜占庭异步模型（Customary asynchronous，non-Byzantine model）。在这种模型下：

* Agent以任意速度运行，它们可能出现fail-stop错误，可能会发生重启。因此需要使得即使Agents发生重启也不会丢失一些关键信息。
* 消息可能花费任意长的时间进行传递，可能重复，可能丢失，但是不会被篡改

### 提案的选举

最简单的选举方式是设置一个单一的Acceptor Agent：Proposer发送提案给Acceptor，**Acceptor选择收到的第一个提案作为最终结果**。虽然简单，但这个解决方案并不满足我们的需求，这是因为Acceptor可能发生单点故障。

换一种思路，设置多个Acceptor Agent：Proposer发送提案给一些Acceptor，当**足够多**的Acceprot收到了提案时就可以进行选择了。怎样算**足够多**呢？为了保证只有一个值被选中，我们可以将这个数额设置为Agent总数的“半数以上”（majority of the Agents）。假设一个Acceptor只能接收一个值，半数以上就确保了任意两个Proposer都至少有一个共同的Acceptor。

在没有消息丢失和机器故障的情况下，即使只有一个Proposer发起了一个提案，这个提案也会被选择。这就需要：**一个Acceptor必须选择第一个到达的提案作为结果**。