# 秒杀、库存、锁

> 针对秒杀场景，有几点需要进行注意：
>
> 1. 防止相同用户重复下单
> 2. 检查库存数量
> 3. 防止库存超扣、超单
> 4. 性能提升不阻塞

## 流程

<img src="https://cdnimg.copyfuture.com/imagesLocal/202005/10/20200510085548659corx8bjvdg9td64_0.png" alt="img"  />

## 如何防重-分布式锁

用分布式锁防止同一个用户在同一秒内多次结算，防止前端点击出现两次重复触发。

```java
String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
```

其中lockKey为Redis的key，可以由用户ID+商品ID+商品数量组成；requestID为Redis的value，实际上是当前线程ID，保证只有一条线程占用。expireTime是key的过期时间，这保证了在一个expiretime周期内不会出现多次重复请求。

## 库存扣减

### 利用分布式锁实现

例如用Redis实现分布式锁，点击结算后，后端以商品ID为分布式锁的key，锁一个商品，但这样其他用户会进入等待阻塞。

优点：安全

缺点：性能差

### 利用MySQL悲观锁实现

请求直接打到数据库，检查库存时使用select xxx for update对当前行加锁，相当于所有订单串行。

缺点：性能差，且所有请求直接打到数据库上造成极大压力

### 利用MySQL乐观锁实现

MySQL的商品数据行加一个版本号。先查询（不加锁）旧版本号和库存，如果库存>0再更新。更新时比较版本号是否与查询一致，如果一致说明没有其他事务正在修改，可以正常进行库存扣减，同时版本号+1。

优点：性能好，多个请求不需阻塞

缺点：直接打到数据库造成压力大

### 利用Redis原子操作+SQL乐观锁实现

将商品库存同步到Redis中，减少Redis压力，商品ID为key，数量为value；同时设置超时时间和更新策略，防止所有的商品ID都在缓存中。

流程：先检查Redis中的库存，如果当前商品ID不在Redis则去数据库查并更新到Redis，同时设置超时时间或更新策略；如果存在，则比较当前库存是否充足（注意这里充足并不代表真正下单时充足）。如果充足则进行第二步，库存扣减，库存扣减是原子操作，返回值时扣减后的值，如果大于0，说明扣减成功，开始进行数据库的CAS乐观锁库存扣减；否则扣减失败，恢复Redis中的库存。

```java
public void order(OrderReq req) {
  String key = "product:" + req.getProductId();
  // 第一步：先检查 库存是否充足
  Integer num = (Integer) redisTemplate.get(key);
  if (num == null){
  // 去查数据库的数据
  // 并且把数据库的库存set进redis，注意使用NX参数表示只有当没有redis中没有这个key的时候才set库存数量到redis
  //注意要设置序列化方式为StringRedisSerializer，不然不能把value做加减操作
  // 同时设置超时时间，因为不能让redis存着所有商品的库存数，以免占用内存。
  if (count >=0) {
  //设置有效期十分钟
  redisTemplate.expire(key, 60*10+随机数防止雪崩, TimeUnit.SECONDS);
  }
  // 减少经常访问数据库，因为磁盘比内存访问速度要慢
  }
  if (num < req.getNum()) {
  logger.info("库存不足");
  }
  // 第二步：减少库存
  long value = redisTemplate.increment(key, -req.getNum().longValue());
  // 库存充足
  if (value >= 0) {
  logger.info("成功购买");
  // update 数据库中商品库存和订单系统下单，单的状态未待支付
  // 分开两个系统处理时，可以用LCN做分布式事务，但是也是有概率会订单系统的网络超时
  // 也可以使用最终一致性的方式，更新库存成功后，发送mq，等待订单创建生成回调。
  boolean res= updateProduct(req);
  if (res)
  createOrder(req);
  } else {
  // 减了后小小于0 ，如两个人同时买这个商品，导致A人第一步时看到还有10个库存，但是B人买9个先处理完逻辑，
  // 导致B人的线程10-9=1, A人的线程1-10=-9，则现在需要增加刚刚减去的库存，让别人可以买1个
  redisTemplate.increment(key, req.getNum().longValue());
  logger.info("恢复redis库存");
  }
}
```

